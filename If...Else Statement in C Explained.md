يُعرف التحكم بالشيفرة المصدرية الشرطي conditional code flow بأنه القدرة التي تستطيع فيها تغيير طريقة تصرف برنامج بناءً على بعض الشروط المحددة، ويمكنك استخدام تعليمات `if` لتحقيق ذلك.

تُعرف تعليمة `if` بأنها تعليمة اتخاذ القرار، إذ إنها تتخذ قرارًا على أساس الشرط condition أو التعبير expression المعطى، وتنفذ الكتلة البرمجية داخل تعليمة `if`إذا كانت قيمة الشرط صحيحة True، وإلا فسيتم تجاوز ما داخل الأقواس المعقوصة curly braces إذا كانت قيمة الشرط خاطئة False، وينفذ عندها التعليمات التي تلي تعليمة `if` مباشرةً.

### كتابة تعليمة `if`

```c
if (testCondition) {
   // statements
}
```

### مثال بسيط

لنلقي نظرة على مثال عملي:

```c
#include <stdio.h>
#include <stdbool.h>

int main(void) {
    if(true) {
        printf("Statement is True!\n");
    }

    return 0;
}
```

**الخرج Output**

```text
Statement is True!
```

يُنفّذ كل ما داخل القوسين المعقوصين إذا كانت الشيفرة البرمجية بداخل قوسين التعليمة `if` صحيحة، وفي هذه الحالة القيمة `true` هي صحيحة وبالتالي تُنفّذ الدالة `printf`.

### تعليمات `if..else`

تُنفذ الشيفرة البرمجية في تعليمة `if…else` إذا كانت الشيفرة البرمجية بين قوسَي التعليمة `if` صحيحة، وتُنفّذ الشيفرة البرمجية التي بداخل تعليمة `else` إذا كانت خاطئة.

المثال السابق ليس مفيدًا لفهم هذه الحالة إذا إن القيمة `true` هي صحيحة دائمًا، وبدلًا منه، دعنا نستعرض مثالًا آخر أكثر واقعية:

```c
#include <stdio.h>

int main(void) {
    int n = 2;

    if(n == 3) { // ‫مقارنة n بالقيمة 3
        printf("Statement is True!\n");
    }
    else { // نفذ هذا الجزء إذا كان الشرط الأول غير محقق
        printf("Statement is False!\n");
    }

    return 0;
}
```

**الخرج**

```text
Statement is False!
```

هناك عدة فروقات هنا في هذه الحالة عمّا سبق، فالمكتبة `stdbool.h` لم تُضمَّن هنا، ولا بأس في ذلك لأن `true` و`false` لا تُستخدمان بالشكل المماثل للمثال الأول. يمكنك استخدام قيمة التعليمات (قيمة `true` أو `false`) في لغة C -كما هي الحالة في لغات البرمجة الأخرى- عوضًا عن استخدام القيم البوليانية بشكل مباشر.

لاحظ أن الشرط `n == 3` الموجود داخل قوسَي التعليمة `if` يُقارن `n` بالرقم 3، حيث أن العامل `==` هو عامل المقارنة  comparison operator في لغة C الذي ينتمي إلى عدّة عوامل أخرى موجودة في اللغة.

### تعليمات `if…else` المتداخلة nested

تسمح لك تعليمات `if…else` باتخاذ القرار بين خيارين، إلا أنك تحتاج إلى الاختيار بين ثلاثة اختيارات أو أكثر في بعض الأحيان.

على سبيل المثال، تُعيد دالة الإشارة sign function في الرياضيات القيمة ‎-1 إذا كانت تبلغ قيمة وسيطه argument أقل من صفر أو ‎+1 إذا كانت قيمة الوسيط أكبر من الصفر، وتُعيد صفر في حال كانت قيمة الوسيط مساوية إلى الصفر.

يطبّق المثال التالي الدالة المذكورة سابقًا:

```c
if (x < 0)
   sign = -1;
else
   if (x == 0)
      sign = 0;
   else
      sign = 1;
```

تعليمة `if…else` الثانية متداخلة مع تعليمة `else` الخاصة بتعليمة `if..else` الأولى.

إذا كان `x` أصغر من الصفر فهذا يعني ضبط قيمة `sign` إلى ‎-1، وإلا فسيتم تنفيذ تعليمة `if…else` الثانية، وهناك إن كانت `x` مساوية للصفر تُضبط `sign` إلى الصفر وإذا كانت `x` أكبر من الصفر تُضبط `sign` إلى 1.

يستخدم المبتدئون عادةً -بدلًا عن استخدام تعليمة `if…else`- سلسلة من تعليمات `if`:

```c
if (x < 0) {
   sign = -1;
}
   
if (x == 0) {
   sign = 0;
}
   
if (x > 0) {
   sign = 1;
}
```

على الرغم من أن المثال السابق يعمل، إلا أننا لا ننصح به لأن لا يوضح أن هناك تعليمة إسناد واحدة تُنفّذ في نهاية المطاف (`sign = ….`) بحسب قيمة `x` كما أن الشيفرة البرمجية السابقة غير فعالة لأن الشروط الثلاث ستُفحص كل مرة حتى لو تم التأكد من صحة أحدها.

### تعليمات `else if`

يمكن استخدام تعليمات `else if` كبديل عن سلسلة متتابعة من تعليمات `if` كما يوضح المثال التالي:

```c
#include <stdio.h>

int main(void) {
    int n = 5;

    if(n == 5) {
        printf("n is equal to 5!\n");
    }
    else if (n > 5) {
        printf("n is greater than 5!\n");
    }

    return 0;
}
```

**الخرج**

```text
n is equal to 5!
```

إذا كان شرط تعليمة `if` خاطئ فهذا يعني أنه سيتم التحقق من شرط تعليمة `else if`، وإذا كان شرطها صحيحًا فستنفّذ الشيفرة البرمجية بداخلها (المحاطة بالأقواس المعقوصة curly braces). 

### عوامل المقارنة

| اسم العامل | الاستخدام | النتيجة |
| -------- | -------- | -------- |
| مساوٍ إلى     | `a == b`     | صحيح إذا كانت `a` مساوية إلى `b` وخاطئ عدا ذلك     |
| لا يساوي إلى     | `a != b`     | صحيح إذا كانت `a` لا تساوي إلى `b` وخاطئ عدا ذلك     |
| أكبر من     | `a > b`     | صحيح إذا كانت `a` أكبر من `b` وخاطئ عدا ذلك     |
| أكبر من أو يساوي     | `a >= b`     | صحيح إذا كانت `a` أكبر من أو مساوية إلى `b` وخاطئ عدا ذلك     |
| أصغر من     | `a < b`     | صحيح إذا كانت `a` أصغر من `b` وخاطئ عدا ذلك     |
| أصغر من أو يساوي     | `a <= b`     | صحيح إذا كانت `a` أصغر من أو مساوية إلى `b` وخاطئ عدا ذلك     |

### العوامل المنطقية

إذا أردنا التحقق من صحة جزء برمجي -أو أكثر- ما فيما إذا كان يُقيم إلى صحيح منطقي True أو خطأ منطقي Flase نستخدم العوامل المنطقية Logical operators:

| اسم العامل | الاستخدام | النتيجة |
| -------- | -------- | -------- |
| ليس `!`     | `‎!( a == 3)‎`     | صحيح إذا كانت `a` **لا** تساوي إلى `3`|
| و `&&`     | `a == 3 && b == 6`     | صحيح إذا كانت `a` تساوي إلى `3` **و**`b` تساوي إلى `6`|
| أو `||`     | `a == 2 || b == 4`     | صحيح إذا كانت `a` تساوي إلى `2` **أو** `b` تساوي إلى `4`|

على سبيل المثال:

```c
#include <stdio.h>

int main(void) {
    int n = 5;
    int m = 10;

    if(n > m || n == 15) {
        printf("Either n is greater than m, or n is equal to 15\n");
    }
    else if( n == 5 && m == 10 ) {
        printf("n is equal to 5 and m is equal to 10!\n");
    }
    else if ( !(n == 6)) {
        printf("It is not true that n is equal to 6!\n");
    }
    else if (n > 5) {
        printf("n is greater than 5!\n");
    }

    return 0;
}
```

**الخرج**

```text
n is equal to 5 and m is equal to 10!
```

### ملاحظة عملية عن المقارنات في لغة C

على الرغم من ذكرنا أن كل مقارنة تتفحص فيما إذا كانت قيمة المقارنة صحيحة أم خاطئة، إلا أن هذه نصف الحقيقة. بالنظر إلى أن لغة C خفيفة وقريبة إلى العتاد الصلب الذي تعمل عليه، فالتحقق من قيمة الشيء إذا كان 0 أو خطأ أمر سهل في عالم العتاد الصلب، إلا أن أي شيء آخر عدا ذلك صعب.

إذا أردنا تحري الدقة، فعلينا القول أن المقارنات في لغة C تتحقق إذا كانت قيمتها 0 أو خطأ، أو إذا كانت أي قيمة مغايرة.

على سبيل المثال، تعليمة `if` التالية صالحة وصحيحة:

```c
if(12452) {
    printf("This is true!\n")
}
```

تقنيًا القيمة صفر هي خاطئة، واصطلاحًا القيمة 1 هي صحيحة. إليك نظرة على مكتبة `stbool.h` للحصول على فهم أعمق:

```c
#define false   0
#define true    1
```

على الرغم من وجود المزيد من التفاصيل حول هذا الأمر، إلا أن هذا هو الأساس في عمل القيم البوليانية وكيفية تعامل المكتبات معها، إذ يوجه السطرين البرمجيين السابقين المصرّف compiler باستبدال الكلمة `flase` بالقيمة 0 والكلمة `true` بالقيمة 1.
